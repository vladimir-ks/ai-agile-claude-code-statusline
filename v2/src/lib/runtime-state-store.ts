/**
 * Runtime State Store - Unified auth profiles + sessions storage
 *
 * Manages ~/.claude/session-health/runtime-state.yaml
 * Two-level structure: auth profiles + sessions
 */

import { existsSync, readFileSync, writeFileSync, renameSync, unlinkSync } from 'fs';
import { join } from 'path';
import { homedir } from 'os';
import YAML from 'yaml';
import {
  RuntimeState,
  AuthProfile,
  RuntimeSession,
  createDefaultRuntimeState,
  createDefaultAuthProfile,
  sessionHealthToRuntimeSession
} from '../types/runtime-state';
import { SessionHealth, BillingInfo } from '../types/session-health';

class RuntimeStateStore {
  private basePath: string;
  private yamlPath: string;
  private jsonPath: string;  // Fallback support

  constructor(basePath?: string) {
    this.basePath = basePath || join(homedir(), '.claude', 'session-health');
    this.yamlPath = join(this.basePath, 'runtime-state.yaml');
    this.jsonPath = join(this.basePath, 'runtime-state.json');
  }

  /**
   * Read runtime state (YAML preferred, JSON fallback)
   */
  read(): RuntimeState {
    // Try YAML first (primary format)
    if (existsSync(this.yamlPath)) {
      try {
        const content = readFileSync(this.yamlPath, 'utf-8');
        if (!content || content.trim() === '') {
          return createDefaultRuntimeState();
        }
        return YAML.parse(content) as RuntimeState;
      } catch (error) {
        console.error('[RuntimeStateStore] Failed to parse YAML:', error);
        // Continue to JSON fallback
      }
    }

    // Fallback to JSON (for backward compatibility)
    if (existsSync(this.jsonPath)) {
      try {
        const content = readFileSync(this.jsonPath, 'utf-8');
        if (!content || content.trim() === '') {
          return createDefaultRuntimeState();
        }
        return JSON.parse(content) as RuntimeState;
      } catch (error) {
        console.error('[RuntimeStateStore] Failed to parse JSON:', error);
      }
    }

    // No file exists - return default
    return createDefaultRuntimeState();
  }

  /**
   * Write runtime state (atomic write to YAML)
   */
  write(state: RuntimeState): void {
    try {
      // Update metadata
      state.metadata.lastUpdated = Date.now();
      state.metadata.totalAuthProfiles = state.authProfiles.length;
      state.metadata.totalActiveSessions = state.sessions.length;

      // Generate YAML with comments for user guidance
      const yamlContent = this.generateYAMLWithComments(state);

      // Atomic write: temp file + rename
      this.atomicWrite(this.yamlPath, yamlContent);
    } catch (error) {
      console.error('[RuntimeStateStore] Failed to write runtime state:', error);
      throw error;
    }
  }

  /**
   * Generate YAML with helpful comments for users
   */
  private generateYAMLWithComments(state: RuntimeState): string {
    // Remove quickLookup from state before stringifying (we'll append it separately)
    const { quickLookup: _, ...stateWithoutQuickLookup } = state as any;

    // Stringify to YAML
    const yamlContent = YAML.stringify(stateWithoutQuickLookup, {
      indent: 2,
      lineWidth: 120,
      sortKeys: false,  // Preserve order
      nullStr: 'null'
    });

    // Add header comment
    const header = `# Claude Code Runtime State
# Auto-generated by statusline data gatherer
# Last updated: ${new Date(state.metadata.lastUpdated).toISOString()}
#
# Structure:
#   authProfiles: Shared billing data per authentication account
#   sessions: Active Claude Code sessions with links to auth profiles
#   quickLookup: Fast lookup of formatted strings by session ID and tmux context
#
# You can manually edit this file to:
#   - Add custom auth profile labels
#   - Define multiple authentication accounts
#   - Adjust billing thresholds
#

`;

    // Generate quick-lookup section at the end for easy debugging and fast access
    const quickLookup = this.generateQuickLookup(state);

    return header + yamlContent + '\n' + quickLookup;
  }

  /**
   * Generate quick-lookup section for formatted strings
   * Organized by session ID and tmux context for easy debugging
   */
  private generateQuickLookup(state: RuntimeState): string {
    const lines: string[] = [];
    lines.push('# ==============================================================================');
    lines.push('# QUICK LOOKUP: Formatted Statusline Strings');
    lines.push('# ==============================================================================');
    lines.push('# For debugging and manual inspection');
    lines.push('# Shows the final output that will be displayed for each session');
    lines.push('#');
    lines.push('# Lookup by:');
    lines.push('#   - Session ID (UUID)');
    lines.push('#   - Tmux context (session:window.pane)');
    lines.push('#   - Project path');
    lines.push('');
    lines.push('quickLookup:');
    lines.push('  bySessionId:');

    // Group by session ID
    for (const session of state.sessions) {
      if (!session.formattedStrings) continue;

      const sessionKey = session.sessionId.substring(0, 8); // First 8 chars for brevity
      lines.push(`    "${session.sessionId}": # ${sessionKey}... - ${session.projectPath}`);

      // Show tmux context if available
      if (session.tmux) {
        lines.push(`      # Tmux: ${session.tmux.session}:${session.tmux.window}.${session.tmux.pane}`);
      }

      // Show width120 as default (most common)
      lines.push(`      width120: |`);
      const formatted = session.formattedStrings.width120.split('\n');
      for (const line of formatted) {
        lines.push(`        ${line}`);
      }
      lines.push('');
    }

    // Group by tmux context (if available)
    // IMPORTANT: Use Map to deduplicate by tmux key (most recent session wins)
    const tmuxSessions = state.sessions.filter(s => s.tmux && s.formattedStrings);
    if (tmuxSessions.length > 0) {
      lines.push('');
      lines.push('  byTmux:');

      // Deduplicate by tmux key - keep only the most recent session for each tmux context
      const tmuxMap = new Map<string, RuntimeSession>();
      for (const session of tmuxSessions) {
        const tmuxKey = `${session.tmux!.session}:${session.tmux!.window}.${session.tmux!.pane}`;
        const existing = tmuxMap.get(tmuxKey);
        // Keep the session with the most recent activity
        if (!existing || (session.metadata?.lastActivity || 0) > (existing.metadata?.lastActivity || 0)) {
          tmuxMap.set(tmuxKey, session);
        }
      }

      for (const [tmuxKey, session] of tmuxMap) {
        lines.push(`    "${tmuxKey}": # Session: ${session.sessionId.substring(0, 8)}...`);
        lines.push(`      # Project: ${session.projectPath}`);
        lines.push(`      width120: |`);
        const formatted = session.formattedStrings!.width120.split('\n');
        for (const line of formatted) {
          lines.push(`        ${line}`);
        }
        lines.push('');
      }
    }

    return lines.join('\n');
  }

  /**
   * Ensure base directory exists
   */
  private ensureDirectory(): void {
    if (!existsSync(this.basePath)) {
      const { mkdirSync } = require('fs');
      mkdirSync(this.basePath, { recursive: true, mode: 0o700 });
    }
  }

  /**
   * Atomic write (temp file + rename)
   */
  private atomicWrite(filePath: string, content: string): void {
    this.ensureDirectory();
    const tempPath = `${filePath}.tmp`;
    try {
      writeFileSync(tempPath, content, { encoding: 'utf-8', mode: 0o600 });
      renameSync(tempPath, filePath);
    } catch (error) {
      // Clean up temp file if it exists
      if (existsSync(tempPath)) {
        try {
          unlinkSync(tempPath);
        } catch {
          // Ignore cleanup errors
        }
      }
      throw error;
    }
  }

  /**
   * Upsert auth profile (create or update)
   */
  upsertAuthProfile(profile: AuthProfile): void {
    const state = this.read();

    const existingIndex = state.authProfiles.findIndex(p => p.profileId === profile.profileId);

    if (existingIndex >= 0) {
      // Update existing
      state.authProfiles[existingIndex] = {
        ...state.authProfiles[existingIndex],
        ...profile,
        metadata: {
          ...state.authProfiles[existingIndex].metadata,
          lastUsed: Date.now()
        }
      };
    } else {
      // Create new
      state.authProfiles.push(profile);
    }

    this.write(state);
  }

  /**
   * Find auth profile by ID
   */
  getAuthProfile(profileId: string): AuthProfile | null {
    const state = this.read();
    return state.authProfiles.find(p => p.profileId === profileId) || null;
  }

  /**
   * Find auth profile by billing fingerprint
   */
  getAuthProfileByFingerprint(fingerprint: string): AuthProfile | null {
    const state = this.read();
    return state.authProfiles.find(p => p.billingFingerprint === fingerprint) || null;
  }

  /**
   * Update billing data for auth profile
   */
  updateAuthProfileBilling(profileId: string, billing: BillingInfo): void {
    const state = this.read();
    const profile = state.authProfiles.find(p => p.profileId === profileId);

    if (profile) {
      profile.billing = {
        costToday: billing.costToday,
        burnRatePerHour: billing.burnRatePerHour,
        budgetRemaining: billing.budgetRemaining,
        budgetPercentUsed: billing.budgetPercentUsed,
        resetTime: billing.resetTime,
        totalTokens: billing.totalTokens || 0,
        tokensPerMinute: billing.tokensPerMinute || null,
        isFresh: billing.isFresh,
        lastFetched: billing.lastFetched
      };
      profile.metadata.lastUsed = Date.now();

      this.write(state);
    }
  }

  /**
   * Upsert session (create or update)
   */
  upsertSession(session: RuntimeSession): void {
    const state = this.read();

    const existingIndex = state.sessions.findIndex(s => s.sessionId === session.sessionId);

    if (existingIndex >= 0) {
      // Update existing
      state.sessions[existingIndex] = session;
    } else {
      // Create new
      state.sessions.push(session);

      // Increment session count for auth profile
      const profile = state.authProfiles.find(p => p.profileId === session.authProfile);
      if (profile) {
        profile.metadata.totalSessions++;
      }
    }

    this.write(state);
  }

  /**
   * Get session by ID
   */
  getSession(sessionId: string): RuntimeSession | null {
    const state = this.read();
    return state.sessions.find(s => s.sessionId === sessionId) || null;
  }

  /**
   * Remove session by ID
   */
  removeSession(sessionId: string): void {
    const state = this.read();
    const initialLength = state.sessions.length;

    state.sessions = state.sessions.filter(s => s.sessionId !== sessionId);

    if (state.sessions.length < initialLength) {
      this.write(state);
    }
  }

  /**
   * Cleanup old sessions (>7 days inactive)
   */
  cleanupOldSessions(daysOld: number = 7): number {
    const state = this.read();
    const cutoff = Date.now() - (daysOld * 24 * 60 * 60 * 1000);
    const initialLength = state.sessions.length;

    state.sessions = state.sessions.filter(s => s.metadata.lastActivity > cutoff);

    const removed = initialLength - state.sessions.length;
    if (removed > 0) {
      this.write(state);
    }

    return removed;
  }

  /**
   * Migrate from existing billing-shared.json and sessions.json
   */
  async migrate(): Promise<void> {
    const state = this.read();

    // Skip if already has data
    if (state.authProfiles.length > 0) {
      return;
    }

    // Check for existing billing-shared.json
    const sharedBillingPath = join(this.basePath, 'billing-shared.json');
    if (existsSync(sharedBillingPath)) {
      try {
        const billing = JSON.parse(readFileSync(sharedBillingPath, 'utf-8'));

        // Create default auth profile with existing billing
        const defaultProfile = createDefaultAuthProfile('default');
        defaultProfile.billing = {
          costToday: billing.costToday || 0,
          burnRatePerHour: billing.burnRatePerHour || 0,
          budgetRemaining: billing.budgetRemaining || 0,
          budgetPercentUsed: billing.budgetPercentUsed || 0,
          resetTime: billing.resetTime || '00:00',
          totalTokens: billing.totalTokens || 0,
          tokensPerMinute: billing.tokensPerMinute || null,
          isFresh: billing.isFresh || false,
          lastFetched: billing.lastFetched || Date.now()
        };

        state.authProfiles.push(defaultProfile);
      } catch (error) {
        console.error('[RuntimeStateStore] Failed to migrate billing-shared.json:', error);
      }
    }

    // If no auth profile created, create empty default
    if (state.authProfiles.length === 0) {
      state.authProfiles.push(createDefaultAuthProfile('default'));
    }

    // Write migrated state
    this.write(state);
  }

  /**
   * Ensure default auth profile exists
   */
  ensureDefaultAuthProfile(): AuthProfile {
    let profile = this.getAuthProfile('default');

    if (!profile) {
      profile = createDefaultAuthProfile('default');
      this.upsertAuthProfile(profile);
    }

    return profile;
  }
}

export default RuntimeStateStore;
